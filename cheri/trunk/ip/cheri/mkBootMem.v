//
// Generated by Bluespec Compiler, version 2019.05.beta2 (build a88bf40, 2019-05-24)
//
// On Sun Mar 22 00:26:26 UTC 2020
//
//
// Ports:
// Name                         I/O  size props
// slave_request_canPut           O     1
// RDY_slave_request_put          O     1
// slave_response_canGet          O     1
// slave_response_peek            O    78
// RDY_slave_response_peek        O     1
// slave_response_get             O    78
// RDY_slave_response_get         O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// slave_request_put_val          I   134
// EN_slave_request_put           I     1
// EN_slave_response_get          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBootMem(CLK,
		 RST_N,

		 slave_request_canPut,

		 slave_request_put_val,
		 EN_slave_request_put,
		 RDY_slave_request_put,

		 slave_response_canGet,

		 slave_response_peek,
		 RDY_slave_response_peek,

		 EN_slave_response_get,
		 slave_response_get,
		 RDY_slave_response_get);
  input  CLK;
  input  RST_N;

  // value method slave_request_canPut
  output slave_request_canPut;

  // action method slave_request_put
  input  [133 : 0] slave_request_put_val;
  input  EN_slave_request_put;
  output RDY_slave_request_put;

  // value method slave_response_canGet
  output slave_response_canGet;

  // value method slave_response_peek
  output [77 : 0] slave_response_peek;
  output RDY_slave_response_peek;

  // actionvalue method slave_response_get
  input  EN_slave_response_get;
  output [77 : 0] slave_response_get;
  output RDY_slave_response_get;

  // value method getIrqs

  // signals for module outputs
  wire [77 : 0] slave_response_get, slave_response_peek;
  wire RDY_slave_request_put,
       RDY_slave_response_get,
       RDY_slave_response_peek,
       slave_request_canPut,
       slave_response_canGet;

  // inlined wires
  wire [134 : 0] req_fifo_rv$port0__write_1,
		 req_fifo_rv$port1__read,
		 req_fifo_rv$port1__write_1,
		 req_fifo_rv$port2__read;
  wire [78 : 0] resp_fifo_rv$port0__write_1,
		resp_fifo_rv$port1__read,
		resp_fifo_rv$port1__write_1,
		resp_fifo_rv$port2__read;
  wire req_fifo_rv$EN_port1__write, resp_fifo_rv$EN_port0__write;

  // register req_fifo_rv
  reg [134 : 0] req_fifo_rv;
  wire [134 : 0] req_fifo_rv$D_IN;
  wire req_fifo_rv$EN;

  // register resp_fifo_rv
  reg [78 : 0] resp_fifo_rv;
  wire [78 : 0] resp_fifo_rv$D_IN;
  wire resp_fifo_rv$EN;

  // ports of submodule bootMem
  wire [85 : 0] bootMem$request_put;
  wire [63 : 0] bootMem$response_get;
  wire bootMem$EN_request_put,
       bootMem$EN_response_get,
       bootMem$RDY_request_put,
       bootMem$RDY_response_get;

  // ports of submodule pend_fifo
  wire [77 : 0] pend_fifo$D_IN, pend_fifo$D_OUT;
  wire pend_fifo$CLR,
       pend_fifo$DEQ,
       pend_fifo$EMPTY_N,
       pend_fifo$ENQ,
       pend_fifo$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_handle_read_response, WILL_FIRE_RL_handle_write_response;

  // inputs to muxes for submodule ports
  wire [78 : 0] MUX_resp_fifo_rv$port0__write_1__VAL_1,
		MUX_resp_fifo_rv$port0__write_1__VAL_2;

  // remaining internal signals
  reg [2 : 0] CASE_resp_fifo_rvport1__read_BITS_67_TO_66_0__ETC__q2;
  reg [1 : 0] CASE_slave_request_put_val_BITS_85_TO_84_0_sla_ETC__q1;

  // value method slave_request_canPut
  assign slave_request_canPut = !req_fifo_rv[134] ;

  // action method slave_request_put
  assign RDY_slave_request_put = !req_fifo_rv[134] ;

  // value method slave_response_canGet
  assign slave_response_canGet = resp_fifo_rv$port1__read[78] ;

  // value method slave_response_peek
  assign slave_response_peek =
	     { resp_fifo_rv$port1__read[77:68],
	       CASE_resp_fifo_rvport1__read_BITS_67_TO_66_0__ETC__q2,
	       resp_fifo_rv$port1__read[64:0] } ;
  assign RDY_slave_response_peek = resp_fifo_rv$port1__read[78] ;

  // actionvalue method slave_response_get
  assign slave_response_get =
	     { resp_fifo_rv$port1__read[77:68],
	       CASE_resp_fifo_rvport1__read_BITS_67_TO_66_0__ETC__q2,
	       resp_fifo_rv$port1__read[64:0] } ;
  assign RDY_slave_response_get = resp_fifo_rv$port1__read[78] ;

  // submodule bootMem
  mkBeriBootMemServer bootMem(.CLK(CLK),
			      .RST_N(RST_N),
			      .request_put(bootMem$request_put),
			      .EN_request_put(bootMem$EN_request_put),
			      .EN_response_get(bootMem$EN_response_get),
			      .RDY_request_put(bootMem$RDY_request_put),
			      .response_get(bootMem$response_get),
			      .RDY_response_get(bootMem$RDY_response_get));

  // submodule pend_fifo
  FIFO2 #(.width(32'd78), .guarded(32'd1)) pend_fifo(.RST(RST_N),
						     .CLK(CLK),
						     .D_IN(pend_fifo$D_IN),
						     .ENQ(pend_fifo$ENQ),
						     .DEQ(pend_fifo$DEQ),
						     .CLR(pend_fifo$CLR),
						     .D_OUT(pend_fifo$D_OUT),
						     .FULL_N(pend_fifo$FULL_N),
						     .EMPTY_N(pend_fifo$EMPTY_N));

  // rule RL_handle_read_response
  assign WILL_FIRE_RL_handle_read_response =
	     bootMem$RDY_response_get && pend_fifo$EMPTY_N &&
	     !resp_fifo_rv[78] &&
	     pend_fifo$D_OUT[67:66] == 2'd0 ;

  // rule RL_handle_write_response
  assign WILL_FIRE_RL_handle_write_response =
	     pend_fifo$EMPTY_N && !resp_fifo_rv[78] &&
	     pend_fifo$D_OUT[67:66] == 2'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_resp_fifo_rv$port0__write_1__VAL_1 =
	     { 1'd1,
	       pend_fifo$D_OUT[77:68],
	       3'd1,
	       pend_fifo$D_OUT[64],
	       bootMem$response_get } ;
  assign MUX_resp_fifo_rv$port0__write_1__VAL_2 =
	     { 1'd1,
	       pend_fifo$D_OUT[77:68],
	       2'd1,
	       1'bx /* unspecified value */ ,
	       pend_fifo$D_OUT[64:0] } ;

  // inlined wires
  assign req_fifo_rv$port0__write_1 =
	     { 1'd1,
	       slave_request_put_val[133:86],
	       CASE_slave_request_put_val_BITS_85_TO_84_0_sla_ETC__q1,
	       slave_request_put_val[83:0] } ;
  assign req_fifo_rv$port1__read =
	     EN_slave_request_put ? req_fifo_rv$port0__write_1 : req_fifo_rv ;
  assign req_fifo_rv$EN_port1__write =
	     req_fifo_rv$port1__read[134] && pend_fifo$FULL_N &&
	     bootMem$RDY_request_put ;
  assign req_fifo_rv$port1__write_1 =
	     { 1'd0,
	       134'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */  } ;
  assign req_fifo_rv$port2__read =
	     req_fifo_rv$EN_port1__write ?
	       req_fifo_rv$port1__write_1 :
	       req_fifo_rv$port1__read ;
  assign resp_fifo_rv$EN_port0__write =
	     WILL_FIRE_RL_handle_read_response ||
	     WILL_FIRE_RL_handle_write_response ;
  assign resp_fifo_rv$port0__write_1 =
	     WILL_FIRE_RL_handle_read_response ?
	       MUX_resp_fifo_rv$port0__write_1__VAL_1 :
	       MUX_resp_fifo_rv$port0__write_1__VAL_2 ;
  assign resp_fifo_rv$port1__read =
	     resp_fifo_rv$EN_port0__write ?
	       resp_fifo_rv$port0__write_1 :
	       resp_fifo_rv ;
  assign resp_fifo_rv$port1__write_1 =
	     { 1'd0,
	       78'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */  } ;
  assign resp_fifo_rv$port2__read =
	     EN_slave_response_get ?
	       resp_fifo_rv$port1__write_1 :
	       resp_fifo_rv$port1__read ;

  // register req_fifo_rv
  assign req_fifo_rv$D_IN = req_fifo_rv$port2__read ;
  assign req_fifo_rv$EN = 1'b1 ;

  // register resp_fifo_rv
  assign resp_fifo_rv$D_IN = resp_fifo_rv$port2__read ;
  assign resp_fifo_rv$EN = 1'b1 ;

  // submodule bootMem
  assign bootMem$request_put =
	     (req_fifo_rv$port1__read[85:84] == 2'd0) ?
	       { 9'd0, req_fifo_rv$port1__read[109:33] } :
	       { req_fifo_rv$port1__read[80:73],
		 1'd0,
		 req_fifo_rv$port1__read[109:97],
		 req_fifo_rv$port1__read[63:0] } ;
  assign bootMem$EN_request_put =
	     req_fifo_rv$port1__read[134] && pend_fifo$FULL_N &&
	     bootMem$RDY_request_put &&
	     (req_fifo_rv$port1__read[85:84] == 2'd0 ||
	      req_fifo_rv$port1__read[85:84] == 2'd1 &&
	      req_fifo_rv$port1__read[80:73] != 8'd0) ;
  assign bootMem$EN_response_get = WILL_FIRE_RL_handle_read_response ;

  // submodule pend_fifo
  assign pend_fifo$D_IN =
	     { req_fifo_rv$port1__read[93:86],
	       2'd0,
	       (req_fifo_rv$port1__read[85:84] == 2'd0) ?
		 req_fifo_rv$port1__read[85:84] :
		 2'd1,
	       1'bx /* unspecified value */ ,
	       65'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */  } ;
  assign pend_fifo$ENQ =
	     req_fifo_rv$port1__read[134] && pend_fifo$FULL_N &&
	     bootMem$RDY_request_put ;
  assign pend_fifo$DEQ =
	     WILL_FIRE_RL_handle_write_response ||
	     WILL_FIRE_RL_handle_read_response ;
  assign pend_fifo$CLR = 1'b0 ;

  // remaining internal signals
  always@(slave_request_put_val)
  begin
    case (slave_request_put_val[85:84])
      2'd0, 2'd1:
	  CASE_slave_request_put_val_BITS_85_TO_84_0_sla_ETC__q1 =
	      slave_request_put_val[85:84];
      default: CASE_slave_request_put_val_BITS_85_TO_84_0_sla_ETC__q1 = 2'd2;
    endcase
  end
  always@(resp_fifo_rv$port1__read)
  begin
    case (resp_fifo_rv$port1__read[67:66])
      2'd0, 2'd1:
	  CASE_resp_fifo_rvport1__read_BITS_67_TO_66_0__ETC__q2 =
	      resp_fifo_rv$port1__read[67:65];
      default: CASE_resp_fifo_rvport1__read_BITS_67_TO_66_0__ETC__q2 =
		   { 2'd2, resp_fifo_rv$port1__read[65] };
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        req_fifo_rv <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0,
	      134'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */  };
	resp_fifo_rv <= `BSV_ASSIGNMENT_DELAY
	    { 1'd0,
	      78'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */  };
      end
    else
      begin
        if (req_fifo_rv$EN)
	  req_fifo_rv <= `BSV_ASSIGNMENT_DELAY req_fifo_rv$D_IN;
	if (resp_fifo_rv$EN)
	  resp_fifo_rv <= `BSV_ASSIGNMENT_DELAY resp_fifo_rv$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    req_fifo_rv = 135'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    resp_fifo_rv = 79'h2AAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkBootMem

