//
// Generated by Bluespec Compiler, version 2019.05.beta2 (build a88bf40, 2019-05-24)
//
// On Sun Mar 22 01:18:44 UTC 2020
//
//
// Ports:
// Name                         I/O  size props
// RDY_muldiv_request_put         O     1
// muldiv_response_get            O   130 reg
// RDY_muldiv_response_get        O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// muldiv_request_put             I   263
// EN_muldiv_request_put          I     1
// EN_muldiv_response_get         I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkMulDiv(CLK,
		RST_N,

		muldiv_request_put,
		EN_muldiv_request_put,
		RDY_muldiv_request_put,

		EN_muldiv_response_get,
		muldiv_response_get,
		RDY_muldiv_response_get);
  input  CLK;
  input  RST_N;

  // action method muldiv_request_put
  input  [262 : 0] muldiv_request_put;
  input  EN_muldiv_request_put;
  output RDY_muldiv_request_put;

  // actionvalue method muldiv_response_get
  input  EN_muldiv_response_get;
  output [129 : 0] muldiv_response_get;
  output RDY_muldiv_response_get;

  // signals for module outputs
  wire [129 : 0] muldiv_response_get;
  wire RDY_muldiv_request_put, RDY_muldiv_response_get;

  // register divint
  reg [265 : 0] divint;
  wire [265 : 0] divint$D_IN;
  wire divint$EN;

  // register mulIntReg
  reg [257 : 0] mulIntReg;
  wire [257 : 0] mulIntReg$D_IN;
  wire mulIntReg$EN;

  // register state
  reg [2 : 0] state;
  reg [2 : 0] state$D_IN;
  wire state$EN;

  // ports of submodule hi_fifo
  reg [64 : 0] hi_fifo$D_IN;
  wire [64 : 0] hi_fifo$D_OUT;
  wire hi_fifo$CLR, hi_fifo$DEQ, hi_fifo$EMPTY_N, hi_fifo$ENQ, hi_fifo$FULL_N;

  // ports of submodule lo_fifo
  reg [64 : 0] lo_fifo$D_IN;
  wire [64 : 0] lo_fifo$D_OUT;
  wire lo_fifo$CLR, lo_fifo$DEQ, lo_fifo$EMPTY_N, lo_fifo$ENQ, lo_fifo$FULL_N;

  // ports of submodule request_fifo
  wire [262 : 0] request_fifo$D_IN, request_fifo$D_OUT;
  wire request_fifo$CLR,
       request_fifo$DEQ,
       request_fifo$EMPTY_N,
       request_fifo$ENQ,
       request_fifo$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_doDivide,
       WILL_FIRE_RL_finishDivide,
       WILL_FIRE_RL_mulPipe2;

  // inputs to muxes for submodule ports
  reg [2 : 0] MUX_state$write_1__VAL_2;
  wire [265 : 0] MUX_divint$write_1__VAL_1, MUX_divint$write_1__VAL_2;
  wire [257 : 0] MUX_mulIntReg$write_1__VAL_1, MUX_mulIntReg$write_1__VAL_2;
  wire [64 : 0] MUX_hi_fifo$enq_1__VAL_1,
		MUX_hi_fifo$enq_1__VAL_2,
		MUX_hi_fifo$enq_1__VAL_3,
		MUX_lo_fifo$enq_1__VAL_1,
		MUX_lo_fifo$enq_1__VAL_2,
		MUX_lo_fifo$enq_1__VAL_3;
  wire MUX_divint$write_1__SEL_1,
       MUX_hi_fifo$enq_1__SEL_1,
       MUX_mulIntReg$write_1__SEL_1,
       MUX_state$write_1__SEL_1,
       MUX_state$write_1__SEL_2,
       MUX_state$write_1__SEL_3;

  // remaining internal signals
  reg [127 : 0] IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC___d65;
  wire [127 : 0] IF_request_fifo_first__1_BIT_262_2_THEN_IF_NOT_ETC___d71,
		 _0_CONCAT_mulIntReg_BITS_129_TO_66_PLUS_0_CONCA_ETC__q3,
		 _0_CONCAT_mulIntReg_BITS_161_TO_130_5_6_MUL_0_C_ETC___d17,
		 _0_CONCAT_mulIntReg_BITS_161_TO_130_5_6_MUL_0_C_ETC___d19,
		 _0_CONCAT_mulIntReg_BITS_225_TO_194_MUL_0_CONCA_ETC___d12,
		 _0_CONCAT_mulIntReg_BITS_225_TO_194_MUL_0_CONCA_ETC___d8,
		 _theResult_____1_dividend__h2779,
		 _theResult____h2021,
		 _theResult___dividend__h2722,
		 mydiv___1_dividend__h2728,
		 mydiv_dividend__h2673,
		 product___1__h2273,
		 product__h2020,
		 product__h2151,
		 product__h2188,
		 product__h2419,
		 x_dividend__h4857;
  wire [63 : 0] _theResult_____1_fst_quotient__h3088,
		_theResult_____1_snd__h3085,
		_theResult_____2__h3043,
		_theResult_____2_fst__h4123,
		_theResult_____2_snd_fst__h4125,
		_theResult___fst__h4154,
		_theResult___quotient__h2723,
		_theResult___quotient__h3106,
		_theResult___snd__h4155,
		a___1__h4162,
		a___1__h4586,
		a___2__h4190,
		a__h3412,
		a__h3439,
		b___1__h4163,
		b___1__h4216,
		b___2__h4191,
		b__h3413,
		b__h3441,
		dividend__h3527,
		mydiv_quotient__h2674,
		mydiv_quotient__h2786,
		newHi__h2150,
		newLo__h2149,
		remainder___1__h3255,
		spliced_bits__h2851,
		x__h2191,
		x__h2422,
		x__h2902;
  wire [31 : 0] IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC__q6,
		IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC__q7,
		muldiv_request_put_BITS_159_TO_128__q2,
		muldiv_request_put_BITS_223_TO_192__q1,
		theResult_____2043_BITS_31_TO_0__q4,
		theResult___quotient106_BITS_31_TO_0__q5;
  wire [7 : 0] _theResult_____1_count__h2781,
	       mydiv___1_count__h2730,
	       mydiv_count__h2675;
  wire IF_divint_8_BITS_200_TO_129_0_EQ_0x0_1_AND_NOT_ETC___d98;

  // action method muldiv_request_put
  assign RDY_muldiv_request_put =
	     state == 3'd0 && request_fifo$FULL_N && hi_fifo$FULL_N &&
	     lo_fifo$FULL_N ;

  // actionvalue method muldiv_response_get
  assign muldiv_response_get = { hi_fifo$D_OUT, lo_fifo$D_OUT } ;
  assign RDY_muldiv_response_get = lo_fifo$EMPTY_N && hi_fifo$EMPTY_N ;

  // submodule hi_fifo
  FIFO2 #(.width(32'd65), .guarded(32'd1)) hi_fifo(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(hi_fifo$D_IN),
						   .ENQ(hi_fifo$ENQ),
						   .DEQ(hi_fifo$DEQ),
						   .CLR(hi_fifo$CLR),
						   .D_OUT(hi_fifo$D_OUT),
						   .FULL_N(hi_fifo$FULL_N),
						   .EMPTY_N(hi_fifo$EMPTY_N));

  // submodule lo_fifo
  FIFO2 #(.width(32'd65), .guarded(32'd1)) lo_fifo(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(lo_fifo$D_IN),
						   .ENQ(lo_fifo$ENQ),
						   .DEQ(lo_fifo$DEQ),
						   .CLR(lo_fifo$CLR),
						   .D_OUT(lo_fifo$D_OUT),
						   .FULL_N(lo_fifo$FULL_N),
						   .EMPTY_N(lo_fifo$EMPTY_N));

  // submodule request_fifo
  FIFO1 #(.width(32'd263), .guarded(32'd1)) request_fifo(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(request_fifo$D_IN),
							 .ENQ(request_fifo$ENQ),
							 .DEQ(request_fifo$DEQ),
							 .CLR(request_fifo$CLR),
							 .D_OUT(request_fifo$D_OUT),
							 .FULL_N(request_fifo$FULL_N),
							 .EMPTY_N(request_fifo$EMPTY_N));

  // rule RL_mulPipe2
  assign WILL_FIRE_RL_mulPipe2 =
	     request_fifo$EMPTY_N && lo_fifo$FULL_N && hi_fifo$FULL_N &&
	     state == 3'd2 ;

  // rule RL_doDivide
  assign WILL_FIRE_RL_doDivide = request_fifo$EMPTY_N && state == 3'd3 ;

  // rule RL_finishDivide
  assign WILL_FIRE_RL_finishDivide =
	     request_fifo$EMPTY_N && lo_fifo$FULL_N && hi_fifo$FULL_N &&
	     state == 3'd4 ;

  // inputs to muxes for submodule ports
  assign MUX_divint$write_1__SEL_1 =
	     EN_muldiv_request_put && muldiv_request_put[260:256] == 5'd12 ;
  assign MUX_hi_fifo$enq_1__SEL_1 =
	     EN_muldiv_request_put &&
	     (muldiv_request_put[260:256] == 5'd16 ||
	      muldiv_request_put[260:256] == 5'd17) ;
  assign MUX_mulIntReg$write_1__SEL_1 =
	     EN_muldiv_request_put &&
	     (muldiv_request_put[260:256] == 5'd11 ||
	      muldiv_request_put[260:256] == 5'd13 ||
	      muldiv_request_put[260:256] == 5'd14 ||
	      muldiv_request_put[260:256] == 5'd15) ;
  assign MUX_state$write_1__SEL_1 =
	     WILL_FIRE_RL_doDivide && _theResult_____1_count__h2781 == 8'd0 ;
  assign MUX_state$write_1__SEL_2 =
	     EN_muldiv_request_put &&
	     (muldiv_request_put[260:256] == 5'd11 ||
	      muldiv_request_put[260:256] == 5'd13 ||
	      muldiv_request_put[260:256] == 5'd14 ||
	      muldiv_request_put[260:256] == 5'd15 ||
	      muldiv_request_put[260:256] == 5'd12) ;
  assign MUX_state$write_1__SEL_3 =
	     WILL_FIRE_RL_finishDivide || WILL_FIRE_RL_mulPipe2 ;
  assign MUX_divint$write_1__VAL_1 =
	     { a__h3439,
	       x_dividend__h4857,
	       72'd64,
	       a__h3439 != 64'd0 && muldiv_request_put[261] && a__h3412[63],
	       a__h3439 != 64'd0 && muldiv_request_put[261] &&
	       b__h3413[63] } ;
  assign MUX_divint$write_1__VAL_2 =
	     { divint[265:202],
	       _theResult_____1_dividend__h2779,
	       x__h2902,
	       _theResult_____1_count__h2781,
	       divint[1:0] } ;
  assign MUX_hi_fifo$enq_1__VAL_1 =
	     { muldiv_request_put[260:256] == 5'd16, a__h3439 } ;
  assign MUX_hi_fifo$enq_1__VAL_2 =
	     { 1'd1,
	       IF_request_fifo_first__1_BIT_262_2_THEN_IF_NOT_ETC___d71[127:64] } ;
  assign MUX_hi_fifo$enq_1__VAL_3 =
	     { 1'd1,
	       request_fifo$D_OUT[262] ?
		 _theResult_____2__h3043 :
		 _theResult_____1_snd__h3085 } ;
  assign MUX_lo_fifo$enq_1__VAL_1 =
	     { muldiv_request_put[260:256] != 5'd16, a__h3439 } ;
  assign MUX_lo_fifo$enq_1__VAL_2 =
	     { 1'd1,
	       IF_request_fifo_first__1_BIT_262_2_THEN_IF_NOT_ETC___d71[63:0] } ;
  assign MUX_lo_fifo$enq_1__VAL_3 =
	     { 1'd1,
	       request_fifo$D_OUT[262] ?
		 _theResult___quotient__h3106 :
		 _theResult_____1_fst_quotient__h3088 } ;
  assign MUX_mulIntReg$write_1__VAL_1 =
	     { 32'd0,
	       b__h3441[63:32],
	       32'd0,
	       b__h3441[31:0],
	       32'd0,
	       a__h3439[63:32],
	       32'd0,
	       a__h3439[31:0],
	       muldiv_request_put[261] && a__h3412[63],
	       muldiv_request_put[261] && b__h3413[63] } ;
  assign MUX_mulIntReg$write_1__VAL_2 =
	     { _0_CONCAT_mulIntReg_BITS_225_TO_194_MUL_0_CONCA_ETC___d8[63:0],
	       _0_CONCAT_mulIntReg_BITS_225_TO_194_MUL_0_CONCA_ETC___d12[63:0],
	       _0_CONCAT_mulIntReg_BITS_161_TO_130_5_6_MUL_0_C_ETC___d17[63:0],
	       _0_CONCAT_mulIntReg_BITS_161_TO_130_5_6_MUL_0_C_ETC___d19[63:0],
	       mulIntReg[1:0] } ;
  always@(muldiv_request_put)
  begin
    case (muldiv_request_put[260:256])
      5'd11, 5'd13, 5'd14, 5'd15: MUX_state$write_1__VAL_2 = 3'd1;
      default: MUX_state$write_1__VAL_2 = 3'd3;
    endcase
  end

  // register divint
  assign divint$D_IN =
	     MUX_divint$write_1__SEL_1 ?
	       MUX_divint$write_1__VAL_1 :
	       MUX_divint$write_1__VAL_2 ;
  assign divint$EN =
	     EN_muldiv_request_put && muldiv_request_put[260:256] == 5'd12 ||
	     WILL_FIRE_RL_doDivide ;

  // register mulIntReg
  assign mulIntReg$D_IN =
	     MUX_mulIntReg$write_1__SEL_1 ?
	       MUX_mulIntReg$write_1__VAL_1 :
	       MUX_mulIntReg$write_1__VAL_2 ;
  assign mulIntReg$EN =
	     EN_muldiv_request_put &&
	     (muldiv_request_put[260:256] == 5'd11 ||
	      muldiv_request_put[260:256] == 5'd13 ||
	      muldiv_request_put[260:256] == 5'd14 ||
	      muldiv_request_put[260:256] == 5'd15) ||
	     state == 3'd1 ;

  // register state
  always@(MUX_state$write_1__SEL_1 or
	  MUX_state$write_1__SEL_2 or
	  MUX_state$write_1__VAL_2 or MUX_state$write_1__SEL_3 or state)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_state$write_1__SEL_1: state$D_IN = 3'd4;
      MUX_state$write_1__SEL_2: state$D_IN = MUX_state$write_1__VAL_2;
      MUX_state$write_1__SEL_3: state$D_IN = 3'd0;
      state == 3'd1: state$D_IN = 3'd2;
      default: state$D_IN = 3'bxxx /* unspecified value */ ;
    endcase
  end
  assign state$EN =
	     WILL_FIRE_RL_doDivide && _theResult_____1_count__h2781 == 8'd0 ||
	     EN_muldiv_request_put &&
	     (muldiv_request_put[260:256] == 5'd11 ||
	      muldiv_request_put[260:256] == 5'd13 ||
	      muldiv_request_put[260:256] == 5'd14 ||
	      muldiv_request_put[260:256] == 5'd15 ||
	      muldiv_request_put[260:256] == 5'd12) ||
	     WILL_FIRE_RL_finishDivide ||
	     WILL_FIRE_RL_mulPipe2 ||
	     state == 3'd1 ;

  // submodule hi_fifo
  always@(MUX_hi_fifo$enq_1__SEL_1 or
	  MUX_hi_fifo$enq_1__VAL_1 or
	  WILL_FIRE_RL_mulPipe2 or
	  MUX_hi_fifo$enq_1__VAL_2 or
	  WILL_FIRE_RL_finishDivide or MUX_hi_fifo$enq_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_hi_fifo$enq_1__SEL_1: hi_fifo$D_IN = MUX_hi_fifo$enq_1__VAL_1;
      WILL_FIRE_RL_mulPipe2: hi_fifo$D_IN = MUX_hi_fifo$enq_1__VAL_2;
      WILL_FIRE_RL_finishDivide: hi_fifo$D_IN = MUX_hi_fifo$enq_1__VAL_3;
      default: hi_fifo$D_IN =
		   65'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */ ;
    endcase
  end
  assign hi_fifo$ENQ =
	     EN_muldiv_request_put &&
	     (muldiv_request_put[260:256] == 5'd16 ||
	      muldiv_request_put[260:256] == 5'd17) ||
	     WILL_FIRE_RL_mulPipe2 ||
	     WILL_FIRE_RL_finishDivide ;
  assign hi_fifo$DEQ = EN_muldiv_response_get ;
  assign hi_fifo$CLR = 1'b0 ;

  // submodule lo_fifo
  always@(MUX_hi_fifo$enq_1__SEL_1 or
	  MUX_lo_fifo$enq_1__VAL_1 or
	  WILL_FIRE_RL_mulPipe2 or
	  MUX_lo_fifo$enq_1__VAL_2 or
	  WILL_FIRE_RL_finishDivide or MUX_lo_fifo$enq_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_hi_fifo$enq_1__SEL_1: lo_fifo$D_IN = MUX_lo_fifo$enq_1__VAL_1;
      WILL_FIRE_RL_mulPipe2: lo_fifo$D_IN = MUX_lo_fifo$enq_1__VAL_2;
      WILL_FIRE_RL_finishDivide: lo_fifo$D_IN = MUX_lo_fifo$enq_1__VAL_3;
      default: lo_fifo$D_IN =
		   65'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */ ;
    endcase
  end
  assign lo_fifo$ENQ =
	     EN_muldiv_request_put &&
	     (muldiv_request_put[260:256] == 5'd16 ||
	      muldiv_request_put[260:256] == 5'd17) ||
	     WILL_FIRE_RL_mulPipe2 ||
	     WILL_FIRE_RL_finishDivide ;
  assign lo_fifo$DEQ = EN_muldiv_response_get ;
  assign lo_fifo$CLR = 1'b0 ;

  // submodule request_fifo
  assign request_fifo$D_IN = muldiv_request_put ;
  assign request_fifo$ENQ = MUX_state$write_1__SEL_2 ;
  assign request_fifo$DEQ = MUX_state$write_1__SEL_3 ;
  assign request_fifo$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_divint_8_BITS_200_TO_129_0_EQ_0x0_1_AND_NOT_ETC___d98 =
	     _theResult___dividend__h2722[127:64] < divint[265:202] ;
  assign IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC__q6 =
	     IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC___d65[63:32] ;
  assign IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC__q7 =
	     IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC___d65[31:0] ;
  assign IF_request_fifo_first__1_BIT_262_2_THEN_IF_NOT_ETC___d71 =
	     request_fifo$D_OUT[262] ? _theResult____h2021 : product__h2151 ;
  assign _0_CONCAT_mulIntReg_BITS_129_TO_66_PLUS_0_CONCA_ETC__q3 =
	     { 64'd0, mulIntReg[129:66] } + { 64'd0, mulIntReg[193:130] } ;
  assign _0_CONCAT_mulIntReg_BITS_161_TO_130_5_6_MUL_0_C_ETC___d17 =
	     { 32'd0, mulIntReg[161:130] } * { 32'd0, mulIntReg[97:66] } ;
  assign _0_CONCAT_mulIntReg_BITS_161_TO_130_5_6_MUL_0_C_ETC___d19 =
	     { 32'd0, mulIntReg[161:130] } * { 32'd0, mulIntReg[33:2] } ;
  assign _0_CONCAT_mulIntReg_BITS_225_TO_194_MUL_0_CONCA_ETC___d12 =
	     { 32'd0, mulIntReg[225:194] } * { 32'd0, mulIntReg[33:2] } ;
  assign _0_CONCAT_mulIntReg_BITS_225_TO_194_MUL_0_CONCA_ETC___d8 =
	     { 32'd0, mulIntReg[225:194] } * { 32'd0, mulIntReg[97:66] } ;
  assign _theResult_____1_count__h2781 =
	     (divint[200:129] == 72'h0 && mydiv_count__h2675 > 8'd9) ?
	       mydiv___1_count__h2730 :
	       mydiv_count__h2675 ;
  assign _theResult_____1_dividend__h2779 =
	     request_fifo$D_OUT[261] ?
	       (spliced_bits__h2851[63] ?
		  _theResult___dividend__h2722 :
		  { spliced_bits__h2851,
		    _theResult___dividend__h2722[63:0] }) :
	       (IF_divint_8_BITS_200_TO_129_0_EQ_0x0_1_AND_NOT_ETC___d98 ?
		  _theResult___dividend__h2722 :
		  { spliced_bits__h2851,
		    _theResult___dividend__h2722[63:0] }) ;
  assign _theResult_____1_fst_quotient__h3088 =
	     { {32{theResult___quotient106_BITS_31_TO_0__q5[31]}},
	       theResult___quotient106_BITS_31_TO_0__q5 } ;
  assign _theResult_____1_snd__h3085 =
	     { {32{theResult_____2043_BITS_31_TO_0__q4[31]}},
	       theResult_____2043_BITS_31_TO_0__q4 } ;
  assign _theResult_____2__h3043 =
	     (divint[0] && request_fifo$D_OUT[261]) ?
	       remainder___1__h3255 :
	       divint[201:138] ;
  assign _theResult_____2_fst__h4123 =
	     a__h3412[63] ? a___1__h4586 : a__h3412 ;
  assign _theResult_____2_snd_fst__h4125 =
	     b__h3413[63] ? b___1__h4216 : b__h3413 ;
  assign _theResult____h2021 =
	     (mulIntReg[1] != mulIntReg[0] && request_fifo$D_OUT[261]) ?
	       product___1__h2273 :
	       product__h2020 ;
  assign _theResult___dividend__h2722 =
	     (divint[200:129] == 72'h0 && mydiv_count__h2675 > 8'd9) ?
	       mydiv___1_dividend__h2728 :
	       mydiv_dividend__h2673 ;
  assign _theResult___fst__h4154 =
	     muldiv_request_put[261] ? a___1__h4162 : a___2__h4190 ;
  assign _theResult___quotient__h2723 =
	     (divint[200:129] == 72'h0 && mydiv_count__h2675 > 8'd9) ?
	       { divint[64:10], 9'd0 } :
	       mydiv_quotient__h2674 ;
  assign _theResult___quotient__h3106 =
	     (divint[1] != divint[0] && request_fifo$D_OUT[261]) ?
	       ~divint[73:10] + 64'd1 :
	       divint[73:10] ;
  assign _theResult___snd__h4155 =
	     muldiv_request_put[261] ? b___1__h4163 : b___2__h4191 ;
  assign a___1__h4162 =
	     { {32{muldiv_request_put_BITS_223_TO_192__q1[31]}},
	       muldiv_request_put_BITS_223_TO_192__q1 } ;
  assign a___1__h4586 = ~(a__h3412 - 64'd1) ;
  assign a___2__h4190 = { 32'd0, muldiv_request_put[223:192] } ;
  assign a__h3412 =
	     muldiv_request_put[262] ?
	       muldiv_request_put[255:192] :
	       _theResult___fst__h4154 ;
  assign a__h3439 =
	     muldiv_request_put[261] ?
	       _theResult_____2_fst__h4123 :
	       a__h3412 ;
  assign b___1__h4163 =
	     { {32{muldiv_request_put_BITS_159_TO_128__q2[31]}},
	       muldiv_request_put_BITS_159_TO_128__q2 } ;
  assign b___1__h4216 = ~(b__h3413 - 64'd1) ;
  assign b___2__h4191 = { 32'd0, muldiv_request_put[159:128] } ;
  assign b__h3413 =
	     muldiv_request_put[262] ?
	       muldiv_request_put[191:128] :
	       _theResult___snd__h4155 ;
  assign b__h3441 =
	     muldiv_request_put[261] ?
	       _theResult_____2_snd_fst__h4125 :
	       b__h3413 ;
  assign dividend__h3527 = (a__h3439 == 64'd0) ? a__h3439 : b__h3441 ;
  assign muldiv_request_put_BITS_159_TO_128__q2 =
	     muldiv_request_put[159:128] ;
  assign muldiv_request_put_BITS_223_TO_192__q1 =
	     muldiv_request_put[223:192] ;
  assign mydiv___1_count__h2730 = mydiv_count__h2675 - 8'd8 ;
  assign mydiv___1_dividend__h2728 = { divint[192:74], 9'd0 } ;
  assign mydiv_count__h2675 = divint[9:2] - 8'd1 ;
  assign mydiv_dividend__h2673 = { divint[200:74], 1'd0 } ;
  assign mydiv_quotient__h2674 = { divint[72:10], 1'd0 } ;
  assign mydiv_quotient__h2786 =
	     { _theResult___quotient__h2723[63:1], 1'd1 } ;
  assign newHi__h2150 =
	     { {32{IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC__q6[31]}},
	       IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC__q6 } ;
  assign newLo__h2149 =
	     { {32{IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC__q7[31]}},
	       IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC__q7 } ;
  assign product___1__h2273 = ~product__h2020 + 128'd1 ;
  assign product__h2020 =
	     { mulIntReg[257:194], mulIntReg[65:2] } +
	     { _0_CONCAT_mulIntReg_BITS_129_TO_66_PLUS_0_CONCA_ETC__q3[95:0],
	       32'd0 } ;
  assign product__h2151 = { newHi__h2150, newLo__h2149 } ;
  assign product__h2188 = { {64{x__h2191[63]}}, x__h2191 } ;
  assign product__h2419 = { {64{x__h2422[63]}}, x__h2422 } ;
  assign remainder___1__h3255 = ~divint[201:138] + 64'd1 ;
  assign spliced_bits__h2851 =
	     _theResult___dividend__h2722[127:64] - divint[265:202] ;
  assign theResult_____2043_BITS_31_TO_0__q4 = _theResult_____2__h3043[31:0] ;
  assign theResult___quotient106_BITS_31_TO_0__q5 =
	     _theResult___quotient__h3106[31:0] ;
  assign x__h2191 =
	     { request_fifo$D_OUT[31:0], request_fifo$D_OUT[95:64] } +
	     _theResult____h2021[63:0] ;
  assign x__h2422 =
	     { request_fifo$D_OUT[31:0], request_fifo$D_OUT[95:64] } -
	     _theResult____h2021[63:0] ;
  assign x__h2902 =
	     request_fifo$D_OUT[261] ?
	       (spliced_bits__h2851[63] ?
		  _theResult___quotient__h2723 :
		  mydiv_quotient__h2786) :
	       (IF_divint_8_BITS_200_TO_129_0_EQ_0x0_1_AND_NOT_ETC___d98 ?
		  _theResult___quotient__h2723 :
		  mydiv_quotient__h2786) ;
  assign x_dividend__h4857 = { 64'h0, dividend__h3527 } ;
  always@(request_fifo$D_OUT or
	  _theResult____h2021 or product__h2188 or product__h2419)
  begin
    case (request_fifo$D_OUT[260:256])
      5'd14:
	  IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC___d65 =
	      product__h2188;
      5'd15:
	  IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC___d65 =
	      product__h2419;
      default: IF_request_fifo_first__1_BITS_260_TO_256_3_EQ__ETC___d65 =
		   _theResult____h2021;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        divint <= `BSV_ASSIGNMENT_DELAY 266'd0;
	state <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (divint$EN) divint <= `BSV_ASSIGNMENT_DELAY divint$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
      end
    if (mulIntReg$EN) mulIntReg <= `BSV_ASSIGNMENT_DELAY mulIntReg$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    divint =
	266'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    mulIntReg =
	258'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    state = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkMulDiv

