//
// Generated by Bluespec Compiler, version 2019.05.beta2 (build a88bf40, 2019-05-24)
//
// On Sun Mar 22 00:26:14 UTC 2020
//
//
// Ports:
// Name                         I/O  size props
// slave_request_canPut           O     1 reg
// RDY_slave_request_put          O     1 reg
// slave_response_canGet          O     1 reg
// slave_response_peek            O   270
// RDY_slave_response_peek        O     1 reg
// slave_response_get             O   270
// RDY_slave_response_get         O     1 reg
// master_ARID                    O     8
// master_ARADDR                  O    40
// master_ARLEN                   O     4
// master_ARSIZE                  O     3
// master_ARBURST                 O     2
// master_ARLOCK                  O     2
// master_ARCACHE                 O     4
// master_ARPROT                  O     3
// master_ARVALID                 O     1 reg
// master_RREADY                  O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// slave_request_put_val          I   350
// master_ARREADY                 I     1
// master_RID                     I     8 reg
// master_RDATA                   I   256 reg
// master_RRESP                   I     2
// master_RLAST                   I     1 reg
// master_RVALID                  I     1
// EN_slave_request_put           I     1
// EN_slave_response_get          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkInternalToAxiRead(CLK,
			   RST_N,

			   slave_request_canPut,

			   slave_request_put_val,
			   EN_slave_request_put,
			   RDY_slave_request_put,

			   slave_response_canGet,

			   slave_response_peek,
			   RDY_slave_response_peek,

			   EN_slave_response_get,
			   slave_response_get,
			   RDY_slave_response_get,

			   master_ARID,

			   master_ARADDR,

			   master_ARLEN,

			   master_ARSIZE,

			   master_ARBURST,

			   master_ARLOCK,

			   master_ARCACHE,

			   master_ARPROT,

			   master_ARVALID,

			   master_ARREADY,

			   master_RREADY,

			   master_RID,

			   master_RDATA,

			   master_RRESP,

			   master_RLAST,

			   master_RVALID);
  input  CLK;
  input  RST_N;

  // value method slave_request_canPut
  output slave_request_canPut;

  // action method slave_request_put
  input  [349 : 0] slave_request_put_val;
  input  EN_slave_request_put;
  output RDY_slave_request_put;

  // value method slave_response_canGet
  output slave_response_canGet;

  // value method slave_response_peek
  output [269 : 0] slave_response_peek;
  output RDY_slave_response_peek;

  // actionvalue method slave_response_get
  input  EN_slave_response_get;
  output [269 : 0] slave_response_get;
  output RDY_slave_response_get;

  // value method master_arID
  output [7 : 0] master_ARID;

  // value method master_arADDR
  output [39 : 0] master_ARADDR;

  // value method master_arLEN
  output [3 : 0] master_ARLEN;

  // value method master_arSIZE
  output [2 : 0] master_ARSIZE;

  // value method master_arBURST
  output [1 : 0] master_ARBURST;

  // value method master_arLOCK
  output [1 : 0] master_ARLOCK;

  // value method master_arCACHE
  output [3 : 0] master_ARCACHE;

  // value method master_arPROT
  output [2 : 0] master_ARPROT;

  // value method master_arVALID
  output master_ARVALID;

  // action method master_arREADY
  input  master_ARREADY;

  // value method master_rREADY
  output master_RREADY;

  // action method master_rID
  input  [7 : 0] master_RID;

  // action method master_rDATA
  input  [255 : 0] master_RDATA;

  // action method master_rRESP
  input  [1 : 0] master_RRESP;

  // action method master_rLAST
  input  master_RLAST;

  // action method master_rVALID
  input  master_RVALID;

  // signals for module outputs
  wire [269 : 0] slave_response_get, slave_response_peek;
  wire [39 : 0] master_ARADDR;
  wire [7 : 0] master_ARID;
  wire [3 : 0] master_ARCACHE, master_ARLEN;
  wire [2 : 0] master_ARPROT, master_ARSIZE;
  wire [1 : 0] master_ARBURST, master_ARLOCK;
  wire RDY_slave_request_put,
       RDY_slave_response_get,
       RDY_slave_response_peek,
       master_ARVALID,
       master_RREADY,
       slave_request_canPut,
       slave_response_canGet;

  // inlined wires
  wire [65 : 0] ar_channel$wget;

  // ports of submodule req
  wire [349 : 0] req$D_IN, req$D_OUT;
  wire req$CLR, req$DEQ, req$EMPTY_N, req$ENQ, req$FULL_N;

  // ports of submodule resp
  wire [269 : 0] resp$D_IN, resp$D_OUT;
  wire resp$CLR, resp$DEQ, resp$EMPTY_N, resp$ENQ, resp$FULL_N;

  // remaining internal signals
  reg [2 : 0] CASE_respD_OUT_BITS_259_TO_258_0_respD_OUT_B_ETC__q1;
  reg [1 : 0] CASE_slave_request_put_val_BITS_301_TO_300_0_s_ETC__q2;
  wire [7 : 0] new_value_id__h814;

  // value method slave_request_canPut
  assign slave_request_canPut = req$FULL_N ;

  // action method slave_request_put
  assign RDY_slave_request_put = req$FULL_N ;

  // value method slave_response_canGet
  assign slave_response_canGet = resp$EMPTY_N ;

  // value method slave_response_peek
  assign slave_response_peek =
	     { resp$D_OUT[269:260],
	       CASE_respD_OUT_BITS_259_TO_258_0_respD_OUT_B_ETC__q1,
	       resp$D_OUT[256:0] } ;
  assign RDY_slave_response_peek = resp$EMPTY_N ;

  // actionvalue method slave_response_get
  assign slave_response_get =
	     { resp$D_OUT[269:260],
	       CASE_respD_OUT_BITS_259_TO_258_0_respD_OUT_B_ETC__q1,
	       resp$D_OUT[256:0] } ;
  assign RDY_slave_response_get = resp$EMPTY_N ;

  // value method master_arID
  assign master_ARID = req$EMPTY_N ? ar_channel$wget[65:58] : 8'd0 ;

  // value method master_arADDR
  assign master_ARADDR = ar_channel$wget[39:0] ;

  // value method master_arLEN
  assign master_ARLEN = req$EMPTY_N ? ar_channel$wget[57:54] : 4'd0 ;

  // value method master_arSIZE
  assign master_ARSIZE = req$EMPTY_N ? ar_channel$wget[53:51] : 3'd0 ;

  // value method master_arBURST
  assign master_ARBURST = req$EMPTY_N ? ar_channel$wget[50:49] : 2'd1 ;

  // value method master_arLOCK
  assign master_ARLOCK = req$EMPTY_N ? ar_channel$wget[48:47] : 2'd0 ;

  // value method master_arCACHE
  assign master_ARCACHE =
	     { req$EMPTY_N && ar_channel$wget[46],
	       req$EMPTY_N && ar_channel$wget[45],
	       req$EMPTY_N && ar_channel$wget[44],
	       req$EMPTY_N && ar_channel$wget[43] } ;

  // value method master_arPROT
  assign master_ARPROT =
	     { req$EMPTY_N && ar_channel$wget[42],
	       req$EMPTY_N && ar_channel$wget[41],
	       req$EMPTY_N && ar_channel$wget[40] } ;

  // value method master_arVALID
  assign master_ARVALID = req$EMPTY_N ;

  // value method master_rREADY
  assign master_RREADY = resp$FULL_N ;

  // submodule req
  FIFO2 #(.width(32'd350), .guarded(32'd1)) req(.RST(RST_N),
						.CLK(CLK),
						.D_IN(req$D_IN),
						.ENQ(req$ENQ),
						.DEQ(req$DEQ),
						.CLR(req$CLR),
						.D_OUT(req$D_OUT),
						.FULL_N(req$FULL_N),
						.EMPTY_N(req$EMPTY_N));

  // submodule resp
  FIFO2 #(.width(32'd270), .guarded(32'd1)) resp(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(resp$D_IN),
						 .ENQ(resp$ENQ),
						 .DEQ(resp$DEQ),
						 .CLR(resp$CLR),
						 .D_OUT(resp$D_OUT),
						 .FULL_N(resp$FULL_N),
						 .EMPTY_N(resp$EMPTY_N));

  // inlined wires
  assign ar_channel$wget =
	     { new_value_id__h814,
	       (req$D_OUT[301:300] == 2'd0) ? { 1'd0, req$D_OUT[5:3] } : 4'd0,
	       (req$D_OUT[301:300] == 2'd0) ? req$D_OUT[2:0] : 3'd0,
	       6'd16,
	       req$D_OUT[301:300] == 2'd0,
	       2'd0,
	       req$D_OUT[301:300] == 2'd0,
	       1'd0,
	       req$D_OUT[349:310] } ;

  // submodule req
  assign req$D_IN =
	     { slave_request_put_val[349:302],
	       CASE_slave_request_put_val_BITS_301_TO_300_0_s_ETC__q2,
	       slave_request_put_val[299:0] } ;
  assign req$ENQ = EN_slave_request_put ;
  assign req$DEQ = req$EMPTY_N && master_ARREADY ;
  assign req$CLR = 1'b0 ;

  // submodule resp
  assign resp$D_IN =
	     { master_RID,
	       (master_RRESP == 2'd0) ? master_RRESP : 2'd2,
	       2'd0,
	       master_RLAST,
	       1'd0,
	       master_RDATA } ;
  assign resp$ENQ = resp$FULL_N && master_RVALID ;
  assign resp$DEQ = EN_slave_response_get ;
  assign resp$CLR = 1'b0 ;

  // remaining internal signals
  assign new_value_id__h814 =
	     (req$D_OUT[301:300] == 2'd0) ? req$D_OUT[309:302] : 8'd0 ;
  always@(resp$D_OUT)
  begin
    case (resp$D_OUT[259:258])
      2'd0, 2'd1:
	  CASE_respD_OUT_BITS_259_TO_258_0_respD_OUT_B_ETC__q1 =
	      resp$D_OUT[259:257];
      default: CASE_respD_OUT_BITS_259_TO_258_0_respD_OUT_B_ETC__q1 =
		   { 2'd2, resp$D_OUT[257] };
    endcase
  end
  always@(slave_request_put_val)
  begin
    case (slave_request_put_val[301:300])
      2'd0, 2'd1:
	  CASE_slave_request_put_val_BITS_301_TO_300_0_s_ETC__q2 =
	      slave_request_put_val[301:300];
      default: CASE_slave_request_put_val_BITS_301_TO_300_0_s_ETC__q2 = 2'd2;
    endcase
  end
endmodule  // mkInternalToAxiRead

