//
// Generated by Bluespec Compiler, version 2019.05.beta2 (build a88bf40, 2019-05-24)
//
// On Sun Mar 22 00:26:15 UTC 2020
//
//
// Ports:
// Name                         I/O  size props
// slave_request_canPut           O     1
// RDY_slave_request_put          O     1
// slave_response_canGet          O     1 reg
// slave_response_peek            O   270
// RDY_slave_response_peek        O     1 reg
// slave_response_get             O   270
// RDY_slave_response_get         O     1 reg
// master_AWID                    O     8
// master_AWADDR                  O    40 reg
// master_AWLEN                   O     4
// master_AWSIZE                  O     3
// master_AWBURST                 O     2
// master_AWLOCK                  O     2
// master_AWCACHE                 O     4
// master_AWPROT                  O     3
// master_AWVALID                 O     1 reg
// master_WID                     O     8
// master_WDATA                   O   256 reg
// master_WSTRB                   O    32
// master_WLAST                   O     1
// master_WVALID                  O     1 reg
// master_BREADY                  O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// slave_request_put_val          I   350
// master_AWREADY                 I     1
// master_WREADY                  I     1
// master_BID                     I     8 reg
// master_BRESP                   I     2
// master_BVALID                  I     1
// EN_slave_request_put           I     1
// EN_slave_response_get          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkInternalToAxiWrite(CLK,
			    RST_N,

			    slave_request_canPut,

			    slave_request_put_val,
			    EN_slave_request_put,
			    RDY_slave_request_put,

			    slave_response_canGet,

			    slave_response_peek,
			    RDY_slave_response_peek,

			    EN_slave_response_get,
			    slave_response_get,
			    RDY_slave_response_get,

			    master_AWID,

			    master_AWADDR,

			    master_AWLEN,

			    master_AWSIZE,

			    master_AWBURST,

			    master_AWLOCK,

			    master_AWCACHE,

			    master_AWPROT,

			    master_AWVALID,

			    master_AWREADY,

			    master_WID,

			    master_WDATA,

			    master_WSTRB,

			    master_WLAST,

			    master_WVALID,

			    master_WREADY,

			    master_BREADY,

			    master_BID,

			    master_BRESP,

			    master_BVALID);
  input  CLK;
  input  RST_N;

  // value method slave_request_canPut
  output slave_request_canPut;

  // action method slave_request_put
  input  [349 : 0] slave_request_put_val;
  input  EN_slave_request_put;
  output RDY_slave_request_put;

  // value method slave_response_canGet
  output slave_response_canGet;

  // value method slave_response_peek
  output [269 : 0] slave_response_peek;
  output RDY_slave_response_peek;

  // actionvalue method slave_response_get
  input  EN_slave_response_get;
  output [269 : 0] slave_response_get;
  output RDY_slave_response_get;

  // value method master_awID
  output [7 : 0] master_AWID;

  // value method master_awADDR
  output [39 : 0] master_AWADDR;

  // value method master_awLEN
  output [3 : 0] master_AWLEN;

  // value method master_awSIZE
  output [2 : 0] master_AWSIZE;

  // value method master_awBURST
  output [1 : 0] master_AWBURST;

  // value method master_awLOCK
  output [1 : 0] master_AWLOCK;

  // value method master_awCACHE
  output [3 : 0] master_AWCACHE;

  // value method master_awPROT
  output [2 : 0] master_AWPROT;

  // value method master_awVALID
  output master_AWVALID;

  // action method master_awREADY
  input  master_AWREADY;

  // value method master_wID
  output [7 : 0] master_WID;

  // value method master_wDATA
  output [255 : 0] master_WDATA;

  // value method master_wSTRB
  output [31 : 0] master_WSTRB;

  // value method master_wLAST
  output master_WLAST;

  // value method master_wVALID
  output master_WVALID;

  // action method master_wREADY
  input  master_WREADY;

  // value method master_bREADY
  output master_BREADY;

  // action method master_bID
  input  [7 : 0] master_BID;

  // action method master_bRESP
  input  [1 : 0] master_BRESP;

  // action method master_bVALID
  input  master_BVALID;

  // signals for module outputs
  wire [269 : 0] slave_response_get, slave_response_peek;
  wire [255 : 0] master_WDATA;
  wire [39 : 0] master_AWADDR;
  wire [31 : 0] master_WSTRB;
  wire [7 : 0] master_AWID, master_WID;
  wire [3 : 0] master_AWCACHE, master_AWLEN;
  wire [2 : 0] master_AWPROT, master_AWSIZE;
  wire [1 : 0] master_AWBURST, master_AWLOCK;
  wire RDY_slave_request_put,
       RDY_slave_response_get,
       RDY_slave_response_peek,
       master_AWVALID,
       master_BREADY,
       master_WLAST,
       master_WVALID,
       slave_request_canPut,
       slave_response_canGet;

  // register aw_done
  reg aw_done;
  wire aw_done$D_IN, aw_done$EN;

  // ports of submodule aw_fifo
  wire [65 : 0] aw_fifo$D_IN, aw_fifo$D_OUT;
  wire aw_fifo$CLR, aw_fifo$DEQ, aw_fifo$EMPTY_N, aw_fifo$ENQ, aw_fifo$FULL_N;

  // ports of submodule resp
  wire [269 : 0] resp$D_IN, resp$D_OUT;
  wire resp$CLR, resp$DEQ, resp$EMPTY_N, resp$ENQ, resp$FULL_N;

  // ports of submodule w_fifo
  wire [296 : 0] w_fifo$D_IN, w_fifo$D_OUT;
  wire w_fifo$CLR, w_fifo$DEQ, w_fifo$EMPTY_N, w_fifo$ENQ, w_fifo$FULL_N;

  // remaining internal signals
  reg [2 : 0] CASE_respD_OUT_BITS_259_TO_258_0_respD_OUT_B_ETC__q1;
  wire [7 : 0] x_id__h1561;

  // value method slave_request_canPut
  assign slave_request_canPut = w_fifo$FULL_N && (aw_done || aw_fifo$FULL_N) ;

  // action method slave_request_put
  assign RDY_slave_request_put = w_fifo$FULL_N && aw_fifo$FULL_N ;

  // value method slave_response_canGet
  assign slave_response_canGet = resp$EMPTY_N ;

  // value method slave_response_peek
  assign slave_response_peek =
	     { resp$D_OUT[269:260],
	       CASE_respD_OUT_BITS_259_TO_258_0_respD_OUT_B_ETC__q1,
	       resp$D_OUT[256:0] } ;
  assign RDY_slave_response_peek = resp$EMPTY_N ;

  // actionvalue method slave_response_get
  assign slave_response_get =
	     { resp$D_OUT[269:260],
	       CASE_respD_OUT_BITS_259_TO_258_0_respD_OUT_B_ETC__q1,
	       resp$D_OUT[256:0] } ;
  assign RDY_slave_response_get = resp$EMPTY_N ;

  // value method master_awID
  assign master_AWID = aw_fifo$EMPTY_N ? aw_fifo$D_OUT[65:58] : 8'd0 ;

  // value method master_awADDR
  assign master_AWADDR = aw_fifo$D_OUT[39:0] ;

  // value method master_awLEN
  assign master_AWLEN = aw_fifo$EMPTY_N ? aw_fifo$D_OUT[57:54] : 4'd0 ;

  // value method master_awSIZE
  assign master_AWSIZE = aw_fifo$EMPTY_N ? aw_fifo$D_OUT[53:51] : 3'd0 ;

  // value method master_awBURST
  assign master_AWBURST = aw_fifo$EMPTY_N ? aw_fifo$D_OUT[50:49] : 2'd1 ;

  // value method master_awLOCK
  assign master_AWLOCK = aw_fifo$EMPTY_N ? aw_fifo$D_OUT[48:47] : 2'd0 ;

  // value method master_awCACHE
  assign master_AWCACHE =
	     { aw_fifo$EMPTY_N && aw_fifo$D_OUT[46],
	       aw_fifo$EMPTY_N && aw_fifo$D_OUT[45],
	       aw_fifo$EMPTY_N && aw_fifo$D_OUT[44],
	       aw_fifo$EMPTY_N && aw_fifo$D_OUT[43] } ;

  // value method master_awPROT
  assign master_AWPROT =
	     { aw_fifo$EMPTY_N && aw_fifo$D_OUT[42],
	       aw_fifo$EMPTY_N && aw_fifo$D_OUT[41],
	       aw_fifo$EMPTY_N && aw_fifo$D_OUT[40] } ;

  // value method master_awVALID
  assign master_AWVALID = aw_fifo$EMPTY_N ;

  // value method master_wID
  assign master_WID = w_fifo$EMPTY_N ? w_fifo$D_OUT[296:289] : 8'd0 ;

  // value method master_wDATA
  assign master_WDATA = w_fifo$D_OUT[288:33] ;

  // value method master_wSTRB
  assign master_WSTRB = w_fifo$EMPTY_N ? w_fifo$D_OUT[32:1] : 32'hFFFFFFFF ;

  // value method master_wLAST
  assign master_WLAST = !w_fifo$EMPTY_N || w_fifo$D_OUT[0] ;

  // value method master_wVALID
  assign master_WVALID = w_fifo$EMPTY_N ;

  // value method master_bREADY
  assign master_BREADY = resp$FULL_N ;

  // submodule aw_fifo
  FIFO2 #(.width(32'd66), .guarded(32'd1)) aw_fifo(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(aw_fifo$D_IN),
						   .ENQ(aw_fifo$ENQ),
						   .DEQ(aw_fifo$DEQ),
						   .CLR(aw_fifo$CLR),
						   .D_OUT(aw_fifo$D_OUT),
						   .FULL_N(aw_fifo$FULL_N),
						   .EMPTY_N(aw_fifo$EMPTY_N));

  // submodule resp
  FIFO2 #(.width(32'd270), .guarded(32'd1)) resp(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(resp$D_IN),
						 .ENQ(resp$ENQ),
						 .DEQ(resp$DEQ),
						 .CLR(resp$CLR),
						 .D_OUT(resp$D_OUT),
						 .FULL_N(resp$FULL_N),
						 .EMPTY_N(resp$EMPTY_N));

  // submodule w_fifo
  FIFO2 #(.width(32'd297), .guarded(32'd1)) w_fifo(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(w_fifo$D_IN),
						   .ENQ(w_fifo$ENQ),
						   .DEQ(w_fifo$DEQ),
						   .CLR(w_fifo$CLR),
						   .D_OUT(w_fifo$D_OUT),
						   .FULL_N(w_fifo$FULL_N),
						   .EMPTY_N(w_fifo$EMPTY_N));

  // register aw_done
  assign aw_done$D_IN = !slave_request_put_val[299] ;
  assign aw_done$EN =
	     EN_slave_request_put && slave_request_put_val[301:300] == 2'd1 ;

  // submodule aw_fifo
  assign aw_fifo$D_IN =
	     { slave_request_put_val[309:302],
	       18'd530,
	       slave_request_put_val[349:310] } ;
  assign aw_fifo$ENQ =
	     EN_slave_request_put && slave_request_put_val[301:300] == 2'd1 &&
	     !aw_done ;
  assign aw_fifo$DEQ = aw_fifo$EMPTY_N && master_AWREADY ;
  assign aw_fifo$CLR = 1'b0 ;

  // submodule resp
  assign resp$D_IN =
	     { master_BID,
	       (master_BRESP == 2'd0) ? master_BRESP : 2'd2,
	       2'd1,
	       1'bx /* unspecified value */ ,
	       257'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx /* unspecified value */  } ;
  assign resp$ENQ = resp$FULL_N && master_BVALID ;
  assign resp$DEQ = EN_slave_response_get ;
  assign resp$CLR = 1'b0 ;

  // submodule w_fifo
  assign w_fifo$D_IN =
	     { x_id__h1561,
	       slave_request_put_val[255:0],
	       slave_request_put_val[296:265],
	       slave_request_put_val[299] } ;
  assign w_fifo$ENQ =
	     EN_slave_request_put && slave_request_put_val[301:300] == 2'd1 ;
  assign w_fifo$DEQ = w_fifo$EMPTY_N && master_WREADY ;
  assign w_fifo$CLR = 1'b0 ;

  // remaining internal signals
  assign x_id__h1561 = { 4'd0, slave_request_put_val[309:306] } ;
  always@(resp$D_OUT)
  begin
    case (resp$D_OUT[259:258])
      2'd0, 2'd1:
	  CASE_respD_OUT_BITS_259_TO_258_0_respD_OUT_B_ETC__q1 =
	      resp$D_OUT[259:257];
      default: CASE_respD_OUT_BITS_259_TO_258_0_respD_OUT_B_ETC__q1 =
		   { 2'd2, resp$D_OUT[257] };
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        aw_done <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (aw_done$EN) aw_done <= `BSV_ASSIGNMENT_DELAY aw_done$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    aw_done = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_slave_request_put && slave_request_put_val[301:300] != 2'd1)
	$display("Dynamic assertion failed: \"../../cherilibs/trunk/InternalToAxi.bsv\", line 431, column 46\nonly write requests are handled");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_slave_request_put && slave_request_put_val[301:300] != 2'd1)
	$finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkInternalToAxiWrite

